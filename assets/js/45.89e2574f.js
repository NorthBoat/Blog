(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{443:function(v,_,l){"use strict";l.r(_);var t=l(56),p=Object(t.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"数据库原理"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据库原理"}},[v._v("#")]),v._v(" 数据库原理")]),v._v(" "),l("p",[v._v("模式分解")]),v._v(" "),l("p",[v._v("矩阵法")]),v._v(" "),l("ol",[l("li",[v._v("极小化处理")]),v._v(" "),l("li",[v._v("去重取并")])]),v._v(" "),l("p",[v._v("分解法")]),v._v(" "),l("p",[v._v("关系一定有码")]),v._v(" "),l("p",[v._v("任何一个二元关系都是3NF、BCNF、4NF")]),v._v(" "),l("p",[v._v("最小函数依赖集算法")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("右部单属性")]),v._v(" "),l("p",[v._v("H->IK，分解为H->I, H->K")])]),v._v(" "),l("li",[l("p",[v._v("无多余依赖")]),v._v(" "),l("p",[v._v("H->J, J->K, K->I, H->I，那么H->I就是多余的")])]),v._v(" "),l("li",[l("p",[v._v("左部无多属性")]),v._v(" "),l("p",[v._v("IJK->L, I->K，那么可以简化为IJ->L, I->K")])])]),v._v(" "),l("p",[v._v("候选码求解算法")]),v._v(" "),l("blockquote",[l("p",[v._v("L类属性：只出现在函数依赖左部的属性")]),v._v(" "),l("p",[v._v("R类属性：只出现在函数依赖右部的属性")]),v._v(" "),l("p",[v._v("LR类属性：同时出现在函数依赖左右部的属性")]),v._v(" "),l("p",[v._v("N类属性：不在F中的函数依赖中出现的属性")])]),v._v(" "),l("p",[v._v("有以下结论")]),v._v(" "),l("ul",[l("li",[v._v("L类属性和N类属性必包含于任一候选码中")]),v._v(" "),l("li",[v._v("R类属性必不包含于任何候选码中")]),v._v(" "),l("li",[v._v("LR类属性不能确定是否在码中")])]),v._v(" "),l("p",[v._v("算法")]),v._v(" "),l("ol",[l("li",[v._v("对码分类")]),v._v(" "),l("li")])])}),[],!1,null,null,null);_.default=p.exports}}]);