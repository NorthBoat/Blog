<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>人工智能导论 | NorthBoat</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/Blog/logo.jpg">
    <meta name="description" content="该博客已停更">
    
    <link rel="preload" href="/Blog/assets/css/0.styles.abe84f2e.css" as="style"><link rel="preload" href="/Blog/assets/js/app.5b462d01.js" as="script"><link rel="preload" href="/Blog/assets/js/2.6b285d51.js" as="script"><link rel="preload" href="/Blog/assets/js/9.6887a164.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.ffffc335.js"><link rel="prefetch" href="/Blog/assets/js/100.31fa9a16.js"><link rel="prefetch" href="/Blog/assets/js/101.2e03c2ea.js"><link rel="prefetch" href="/Blog/assets/js/102.c91a2d9c.js"><link rel="prefetch" href="/Blog/assets/js/103.37a07655.js"><link rel="prefetch" href="/Blog/assets/js/104.da02b323.js"><link rel="prefetch" href="/Blog/assets/js/105.202b7598.js"><link rel="prefetch" href="/Blog/assets/js/106.27a009e9.js"><link rel="prefetch" href="/Blog/assets/js/107.1f98fc4c.js"><link rel="prefetch" href="/Blog/assets/js/108.58c5bc28.js"><link rel="prefetch" href="/Blog/assets/js/109.93c6f88b.js"><link rel="prefetch" href="/Blog/assets/js/11.1a4f7260.js"><link rel="prefetch" href="/Blog/assets/js/110.4288cfb9.js"><link rel="prefetch" href="/Blog/assets/js/111.80efb004.js"><link rel="prefetch" href="/Blog/assets/js/112.5dcc3a84.js"><link rel="prefetch" href="/Blog/assets/js/113.dc7ea58f.js"><link rel="prefetch" href="/Blog/assets/js/114.27030405.js"><link rel="prefetch" href="/Blog/assets/js/115.f2688d1d.js"><link rel="prefetch" href="/Blog/assets/js/116.6521a3f7.js"><link rel="prefetch" href="/Blog/assets/js/117.fee2d3ef.js"><link rel="prefetch" href="/Blog/assets/js/118.b8c936ff.js"><link rel="prefetch" href="/Blog/assets/js/119.25f1736e.js"><link rel="prefetch" href="/Blog/assets/js/12.a73e19a9.js"><link rel="prefetch" href="/Blog/assets/js/120.527e6dda.js"><link rel="prefetch" href="/Blog/assets/js/121.de77f07e.js"><link rel="prefetch" href="/Blog/assets/js/122.cf40de3c.js"><link rel="prefetch" href="/Blog/assets/js/123.c1b8a029.js"><link rel="prefetch" href="/Blog/assets/js/124.5e130ecb.js"><link rel="prefetch" href="/Blog/assets/js/125.7176a383.js"><link rel="prefetch" href="/Blog/assets/js/126.e31ce3bb.js"><link rel="prefetch" href="/Blog/assets/js/127.68215566.js"><link rel="prefetch" href="/Blog/assets/js/128.1f8f543f.js"><link rel="prefetch" href="/Blog/assets/js/129.ead46405.js"><link rel="prefetch" href="/Blog/assets/js/13.0fe329a7.js"><link rel="prefetch" href="/Blog/assets/js/130.812ec31b.js"><link rel="prefetch" href="/Blog/assets/js/131.57da5f16.js"><link rel="prefetch" href="/Blog/assets/js/132.717bef61.js"><link rel="prefetch" href="/Blog/assets/js/133.03cd25a2.js"><link rel="prefetch" href="/Blog/assets/js/14.1a86e8ba.js"><link rel="prefetch" href="/Blog/assets/js/15.484b65c2.js"><link rel="prefetch" href="/Blog/assets/js/16.682f178e.js"><link rel="prefetch" href="/Blog/assets/js/17.fa9336c5.js"><link rel="prefetch" href="/Blog/assets/js/18.39a4278d.js"><link rel="prefetch" href="/Blog/assets/js/19.e36a7c70.js"><link rel="prefetch" href="/Blog/assets/js/20.d9cf0aae.js"><link rel="prefetch" href="/Blog/assets/js/21.53064cbb.js"><link rel="prefetch" href="/Blog/assets/js/22.2ba17f83.js"><link rel="prefetch" href="/Blog/assets/js/23.fced31b8.js"><link rel="prefetch" href="/Blog/assets/js/24.340def84.js"><link rel="prefetch" href="/Blog/assets/js/25.58765567.js"><link rel="prefetch" href="/Blog/assets/js/26.8fe79f81.js"><link rel="prefetch" href="/Blog/assets/js/27.52df13b2.js"><link rel="prefetch" href="/Blog/assets/js/28.c9c7aaa9.js"><link rel="prefetch" href="/Blog/assets/js/29.7d46cab6.js"><link rel="prefetch" href="/Blog/assets/js/3.3025d786.js"><link rel="prefetch" href="/Blog/assets/js/30.a5cbbcd3.js"><link rel="prefetch" href="/Blog/assets/js/31.a3fe64fb.js"><link rel="prefetch" href="/Blog/assets/js/32.6f4b71df.js"><link rel="prefetch" href="/Blog/assets/js/33.f4870de4.js"><link rel="prefetch" href="/Blog/assets/js/34.a173ef06.js"><link rel="prefetch" href="/Blog/assets/js/35.a1137b9f.js"><link rel="prefetch" href="/Blog/assets/js/36.7a5ee652.js"><link rel="prefetch" href="/Blog/assets/js/37.253afd16.js"><link rel="prefetch" href="/Blog/assets/js/38.890dd74c.js"><link rel="prefetch" href="/Blog/assets/js/39.7a65a98a.js"><link rel="prefetch" href="/Blog/assets/js/4.2b42870a.js"><link rel="prefetch" href="/Blog/assets/js/40.f7532a18.js"><link rel="prefetch" href="/Blog/assets/js/41.aeb25632.js"><link rel="prefetch" href="/Blog/assets/js/42.6bcf4a55.js"><link rel="prefetch" href="/Blog/assets/js/43.348b83fb.js"><link rel="prefetch" href="/Blog/assets/js/44.6642a470.js"><link rel="prefetch" href="/Blog/assets/js/45.89e2574f.js"><link rel="prefetch" href="/Blog/assets/js/46.a9b0583a.js"><link rel="prefetch" href="/Blog/assets/js/47.70d0b6dc.js"><link rel="prefetch" href="/Blog/assets/js/48.d4201c5f.js"><link rel="prefetch" href="/Blog/assets/js/49.3381ed30.js"><link rel="prefetch" href="/Blog/assets/js/5.0fa05cd6.js"><link rel="prefetch" href="/Blog/assets/js/50.a429a35d.js"><link rel="prefetch" href="/Blog/assets/js/51.b58173cd.js"><link rel="prefetch" href="/Blog/assets/js/52.f05dc7dd.js"><link rel="prefetch" href="/Blog/assets/js/53.8391280d.js"><link rel="prefetch" href="/Blog/assets/js/54.17499480.js"><link rel="prefetch" href="/Blog/assets/js/55.9cd0e22f.js"><link rel="prefetch" href="/Blog/assets/js/56.5b17cbe1.js"><link rel="prefetch" href="/Blog/assets/js/57.f4ad5c1f.js"><link rel="prefetch" href="/Blog/assets/js/58.b013938d.js"><link rel="prefetch" href="/Blog/assets/js/59.1159eb77.js"><link rel="prefetch" href="/Blog/assets/js/6.e61f80cf.js"><link rel="prefetch" href="/Blog/assets/js/60.401d42b2.js"><link rel="prefetch" href="/Blog/assets/js/61.f0f7b454.js"><link rel="prefetch" href="/Blog/assets/js/62.fec8b981.js"><link rel="prefetch" href="/Blog/assets/js/63.1ca31b20.js"><link rel="prefetch" href="/Blog/assets/js/64.a028dfc6.js"><link rel="prefetch" href="/Blog/assets/js/65.b37496cb.js"><link rel="prefetch" href="/Blog/assets/js/66.7365dded.js"><link rel="prefetch" href="/Blog/assets/js/67.83d9d157.js"><link rel="prefetch" href="/Blog/assets/js/68.2992ee7b.js"><link rel="prefetch" href="/Blog/assets/js/69.301aded2.js"><link rel="prefetch" href="/Blog/assets/js/7.2e00c8c9.js"><link rel="prefetch" href="/Blog/assets/js/70.dcd1be9b.js"><link rel="prefetch" href="/Blog/assets/js/71.3fc4c611.js"><link rel="prefetch" href="/Blog/assets/js/72.1157b20c.js"><link rel="prefetch" href="/Blog/assets/js/73.8fafa20a.js"><link rel="prefetch" href="/Blog/assets/js/74.24093a1e.js"><link rel="prefetch" href="/Blog/assets/js/75.d8a1eadb.js"><link rel="prefetch" href="/Blog/assets/js/76.6f899447.js"><link rel="prefetch" href="/Blog/assets/js/77.bcee3cda.js"><link rel="prefetch" href="/Blog/assets/js/78.153a311c.js"><link rel="prefetch" href="/Blog/assets/js/79.3685754f.js"><link rel="prefetch" href="/Blog/assets/js/8.26736618.js"><link rel="prefetch" href="/Blog/assets/js/80.6bd9098a.js"><link rel="prefetch" href="/Blog/assets/js/81.725d4c95.js"><link rel="prefetch" href="/Blog/assets/js/82.a20dee6c.js"><link rel="prefetch" href="/Blog/assets/js/83.5f8df008.js"><link rel="prefetch" href="/Blog/assets/js/84.d71ced19.js"><link rel="prefetch" href="/Blog/assets/js/85.567f3716.js"><link rel="prefetch" href="/Blog/assets/js/86.aa9eabe6.js"><link rel="prefetch" href="/Blog/assets/js/87.d4b035f1.js"><link rel="prefetch" href="/Blog/assets/js/88.a8094f9e.js"><link rel="prefetch" href="/Blog/assets/js/89.6aa12ab8.js"><link rel="prefetch" href="/Blog/assets/js/90.80e6f2ba.js"><link rel="prefetch" href="/Blog/assets/js/91.acd1dc71.js"><link rel="prefetch" href="/Blog/assets/js/92.94c291ae.js"><link rel="prefetch" href="/Blog/assets/js/93.50ebc5d2.js"><link rel="prefetch" href="/Blog/assets/js/94.4cf101b8.js"><link rel="prefetch" href="/Blog/assets/js/95.674db06a.js"><link rel="prefetch" href="/Blog/assets/js/96.fa4b1651.js"><link rel="prefetch" href="/Blog/assets/js/97.75bb55af.js"><link rel="prefetch" href="/Blog/assets/js/98.7f9892c0.js"><link rel="prefetch" href="/Blog/assets/js/99.1b210598.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.abe84f2e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">NorthBoat</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Mine" class="dropdown-title"><span class="title">Mine</span> <span class="arrow down"></span></button> <button type="button" aria-label="Mine" class="mobile-dropdown-title"><span class="title">Mine</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/mine/notes/" class="nav-link">
  Notes
</a></li><li class="dropdown-item"><!----> <a href="/Blog/mine/project/" class="nav-link">
  Project
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Professional Courses" class="dropdown-title"><span class="title">Professional Courses</span> <span class="arrow down"></span></button> <button type="button" aria-label="Professional Courses" class="mobile-dropdown-title"><span class="title">Professional Courses</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/course/compilation/" class="nav-link">
  Compilation
</a></li><li class="dropdown-item"><!----> <a href="/Blog/course/os/" class="nav-link">
  Operating System
</a></li><li class="dropdown-item"><!----> <a href="/Blog/course/net/" class="nav-link">
  Network
</a></li><li class="dropdown-item"><!----> <a href="/Blog/course/datastruct/" class="nav-link">
  Datastruct
</a></li><li class="dropdown-item"><!----> <a href="/Blog/course/db/" class="nav-link">
  Data Base
</a></li><li class="dropdown-item"><!----> <a href="/Blog/course/organization/" class="nav-link">
  Organization
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Programming" class="dropdown-title"><span class="title">Programming</span> <span class="arrow down"></span></button> <button type="button" aria-label="Programming" class="mobile-dropdown-title"><span class="title">Programming</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/programming/c++/" class="nav-link">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/Blog/programming/java/" class="nav-link">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/Blog/programming/front/" class="nav-link">
  Front End
</a></li><li class="dropdown-item"><!----> <a href="/Blog/programming/linux/" class="nav-link">
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/Blog/programming/golang/" class="nav-link">
  Golang
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Tools" class="dropdown-title"><span class="title">Tools</span> <span class="arrow down"></span></button> <button type="button" aria-label="Tools" class="mobile-dropdown-title"><span class="title">Tools</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/tools/git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/Blog/tools/docker/" class="nav-link">
  Docker
</a></li><li class="dropdown-item"><!----> <a href="/Blog/tools/api/" class="nav-link">
  API
</a></li><li class="dropdown-item"><!----> <a href="/Blog/tools/java/" class="nav-link">
  Java Tool
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Artificial Intelligence" class="dropdown-title"><span class="title">Artificial Intelligence</span> <span class="arrow down"></span></button> <button type="button" aria-label="Artificial Intelligence" class="mobile-dropdown-title"><span class="title">Artificial Intelligence</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/ai/toys/" class="nav-link">
  Toys
</a></li><li class="dropdown-item"><!----> <a href="/Blog/ai/course/" class="nav-link router-link-active">
  Course
</a></li><li class="dropdown-item"><!----> <a href="/Blog/ai/python/" class="nav-link">
  Python
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Mine" class="dropdown-title"><span class="title">Mine</span> <span class="arrow down"></span></button> <button type="button" aria-label="Mine" class="mobile-dropdown-title"><span class="title">Mine</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/mine/notes/" class="nav-link">
  Notes
</a></li><li class="dropdown-item"><!----> <a href="/Blog/mine/project/" class="nav-link">
  Project
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Professional Courses" class="dropdown-title"><span class="title">Professional Courses</span> <span class="arrow down"></span></button> <button type="button" aria-label="Professional Courses" class="mobile-dropdown-title"><span class="title">Professional Courses</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/course/compilation/" class="nav-link">
  Compilation
</a></li><li class="dropdown-item"><!----> <a href="/Blog/course/os/" class="nav-link">
  Operating System
</a></li><li class="dropdown-item"><!----> <a href="/Blog/course/net/" class="nav-link">
  Network
</a></li><li class="dropdown-item"><!----> <a href="/Blog/course/datastruct/" class="nav-link">
  Datastruct
</a></li><li class="dropdown-item"><!----> <a href="/Blog/course/db/" class="nav-link">
  Data Base
</a></li><li class="dropdown-item"><!----> <a href="/Blog/course/organization/" class="nav-link">
  Organization
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Programming" class="dropdown-title"><span class="title">Programming</span> <span class="arrow down"></span></button> <button type="button" aria-label="Programming" class="mobile-dropdown-title"><span class="title">Programming</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/programming/c++/" class="nav-link">
  C++
</a></li><li class="dropdown-item"><!----> <a href="/Blog/programming/java/" class="nav-link">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/Blog/programming/front/" class="nav-link">
  Front End
</a></li><li class="dropdown-item"><!----> <a href="/Blog/programming/linux/" class="nav-link">
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/Blog/programming/golang/" class="nav-link">
  Golang
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Tools" class="dropdown-title"><span class="title">Tools</span> <span class="arrow down"></span></button> <button type="button" aria-label="Tools" class="mobile-dropdown-title"><span class="title">Tools</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/tools/git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/Blog/tools/docker/" class="nav-link">
  Docker
</a></li><li class="dropdown-item"><!----> <a href="/Blog/tools/api/" class="nav-link">
  API
</a></li><li class="dropdown-item"><!----> <a href="/Blog/tools/java/" class="nav-link">
  Java Tool
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Artificial Intelligence" class="dropdown-title"><span class="title">Artificial Intelligence</span> <span class="arrow down"></span></button> <button type="button" aria-label="Artificial Intelligence" class="mobile-dropdown-title"><span class="title">Artificial Intelligence</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/ai/toys/" class="nav-link">
  Toys
</a></li><li class="dropdown-item"><!----> <a href="/Blog/ai/course/" class="nav-link router-link-active">
  Course
</a></li><li class="dropdown-item"><!----> <a href="/Blog/ai/python/" class="nav-link">
  Python
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>导论</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Blog/ai/course/pre/CS188.html" aria-current="page" class="active sidebar-link">人工智能导论</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/ai/course/pre/CS188.html#一、搜索与规划" class="sidebar-link">一、搜索与规划</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/ai/course/pre/CS188.html#_1、search" class="sidebar-link">1、Search</a></li><li class="sidebar-sub-header"><a href="/Blog/ai/course/pre/CS188.html#_2、csps" class="sidebar-link">2、CSPs</a></li><li class="sidebar-sub-header"><a href="/Blog/ai/course/pre/CS188.html#_3、games" class="sidebar-link">3、Games</a></li><li class="sidebar-sub-header"><a href="/Blog/ai/course/pre/CS188.html#_4、mdps" class="sidebar-link">4、MDPs</a></li><li class="sidebar-sub-header"><a href="/Blog/ai/course/pre/CS188.html#_5、rl" class="sidebar-link">5、RL</a></li></ul></li><li class="sidebar-sub-header"><a href="/Blog/ai/course/pre/CS188.html#二、不确定知识和推理" class="sidebar-link">二、不确定知识和推理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/ai/course/pre/CS188.html#_1、probability" class="sidebar-link">1、Probability</a></li><li class="sidebar-sub-header"><a href="/Blog/ai/course/pre/CS188.html#_2、bayes-nets" class="sidebar-link">2、Bayes' Nets</a></li></ul></li><li class="sidebar-sub-header"><a href="/Blog/ai/course/pre/CS188.html#三、机器学习" class="sidebar-link">三、机器学习</a></li></ul></li><li><a href="/Blog/ai/course/pre/Optimization.html" class="sidebar-link">最优化导论</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="人工智能导论"><a href="#人工智能导论" class="header-anchor">#</a> 人工智能导论</h1> <p>Intro to AI</p> <ul><li><p>think like humam</p></li> <li><p>think rationally</p></li> <li><p>act like human</p></li> <li><p>act rationally</p></li></ul> <h2 id="一、搜索与规划"><a href="#一、搜索与规划" class="header-anchor">#</a> 一、搜索与规划</h2> <blockquote><p>Search and Planning</p></blockquote> <h3 id="_1、search"><a href="#_1、search" class="header-anchor">#</a> 1、Search</h3> <h4 id="_1-1、uninformed-search"><a href="#_1-1、uninformed-search" class="header-anchor">#</a> 1.1、Uninformed Search</h4> <p>Search Properties</p> <ul><li>State</li> <li>Successor</li> <li>Start</li> <li>Solution（Goal）</li></ul> <p>State Space Graphs and Search Trees</p> <ul><li>node</li> <li>expand</li> <li>fringe</li></ul> <p>Search Strategy</p> <ul><li>DFS（深度优先搜索）</li> <li>BFS（广度优先搜索）</li> <li>IDS（迭代加深搜索）</li> <li>UCS（统一代价搜索）</li></ul> <p>Search Algorithm Properties（属性）</p> <ul><li>完备性</li> <li>最优性</li> <li>时间复杂度</li> <li>空间复杂度</li></ul> <p>When the search tree is finite</p> <table><thead><tr><th>Strategy</th> <th>space</th> <th>complete</th> <th>optimal</th> <th>time</th></tr></thead> <tbody><tr><td>DFS</td> <td>O(bm)</td> <td>√</td> <td>×</td> <td>O(b^m)</td></tr> <tr><td>BFS</td> <td>O(b^s)</td> <td>√</td> <td>×</td> <td>O(b^s</td></tr></tbody></table> <p>Trade-Offs BFS&amp;DFS （权衡）</p> <p>1、Iterative Deepening Search：迭代加深搜索</p> <ul><li>base on layer</li></ul> <blockquote><p>一层一层向下搜的意思</p> <p>这样会造成浪费，比如第一次搜5层，第二次搜10层，第二次搜索仍旧需要经历第一次搜索的前五层</p> <p>但这种浪费并不是特别大，每加的一层是所有前面层数之和，何不忽略一下</p></blockquote> <ul><li>always run dfs</li> <li>cap the depth you are willing to search when get the depth</li> <li>if get the solution then return, if not, going on searching the next depth</li></ul> <p>2、Uniform Cost Search：统一代价搜索</p> <ul><li>base on cost so far</li></ul> <blockquote><p>永远选择代价最小的节点优先扩展</p> <p>当找到Goal时，记录他的代价cost，继续搜索代价还没到达cost的路径，直到所有路径的代价都大于等于cost，返回当前Goal</p></blockquote> <ul><li>expand a cheapest node first</li> <li>fringe is priority queue</li></ul> <table><thead><tr><th>Strategy</th> <th>space</th> <th>time</th> <th>optimal</th> <th>complete</th></tr></thead> <tbody><tr><td>UCS</td> <td>O(b^(*/ε))</td> <td>O(b^(*/ε))</td> <td>√</td> <td>√</td></tr></tbody></table> <ul><li>Issues: it explores every direction, which could be very expensive</li> <li>Solution: focus on things that are promising（有希望的）rather than that have been cheap so far</li></ul> <p>What we should do for example is that use one piece of code to maintains a priority queue by different strategy when facing different situation, Such as using DFS when the search tree is deep, using BFS when the tree is shallow, using UCS when particularly considering the cost so far on current path</p> <h4 id="_1-2、infomed-search"><a href="#_1-2、infomed-search" class="header-anchor">#</a> 1.2、Infomed Search</h4> <blockquote><p>截止日期放到周五下午四点能有效帮助度过一个舒服的周末</p> <p>搜索算法是系统的构建搜索树的方法，希望在搜索树的一部分便找到答案，最差的情况是构建了整个搜索树</p></blockquote> <p>不同的搜索算法的实际区别其实就是扩展边缘的方法不同</p> <table><thead><tr><th>Algorithm</th> <th>check</th></tr></thead> <tbody><tr><td>DFS</td> <td>stack</td></tr> <tr><td>BFS</td> <td>queue</td></tr> <tr><td>some other</td> <td>priority queue</td></tr></tbody></table> <h5 id="_1-2-1、heurisics-启发式"><a href="#_1-2-1、heurisics-启发式" class="header-anchor">#</a> 1.2.1、heurisics（启发式）</h5> <blockquote><p>estimate of distance to nearest goal for each state</p></blockquote> <p>heurisics function（启发函数）：测量距离goal的距离</p> <p>通常使用减法而不是测量已走过的距离，即计算剩余的距离，直到距离为<code>0</code>找到<code>goal</code></p> <p>启发式只是一种估算，当遇到非常糟糕的启发式，估算结果可能会非常离谱</p> <h5 id="_1-2-2、greedy-search"><a href="#_1-2-2、greedy-search" class="header-anchor">#</a> 1.2.2、Greedy Search</h5> <p>通过启发式函数找到最接近goal的fringe，进行扩展</p> <p>不同于一致代价搜索，一致代价搜索是找的代价最小的fringe，即深度最小的进行搜索，是盲目的，而贪婪搜索基于当前node到goal的距离进行有信息的搜索</p> <p>选择局部最有利的节点进行扩展，忽略已耗费的代价，很有可能不是全局最有利的，甚至有可能走到头距离不能为0，即找不到goal</p> <p>ucs is the tortoise（龟）, and greedy is the hare（兔）</p> <h5 id="_1-2-3、a-star-search-a-search"><a href="#_1-2-3、a-star-search-a-search" class="header-anchor">#</a> 1.2.3、A Star Search (A* Search)</h5> <p>combine the tortoise and hare</p> <p>同时考虑代价（g）和距目标距离（h），选择<code>min(Node.g+Node.h)</code>的节点进行扩展，当找到goal时（s=0），pop出节点得到结果<code>d</code>（实际距离），不宣布成功，继续选择<code>n</code>节点满足<code>f(n)&lt;d</code>进行扩展，当新弹出的节点实际路径小于<code>d</code>，更新<code>d</code>，直到没有节点满足<code>f(n)&lt;d</code>时，宣布成功</p> <p>当实际成本小于估计成本，即预估<code>h</code>偏大，A*搜索很可能会略过这样的节点从而丢失最优解</p> <p>可容的（乐观的）启发式：其预估成本总小于或等于实际成本</p> <ul><li><p>如用城市的直线距离作为启发方式是一种乐观启发</p></li> <li><p>0 &lt;= h(n) &lt;= h*(n)</p> <p>每个节点的启发式值低于或等于从当前节点到目标成本最少的路径大小</p> <p>当h(n)为0时即为统一代价搜索</p> <p>当h(n)越接近h*(n)，效率越高</p></li></ul> <p>当使用的启发式是可接受的，那么我们说A*的树搜索将是最佳的</p> <p>由于预计成本总小于实际成本，或许<code>b</code>已经很接近<code>goal</code>，但它已消耗的代价<code>h(b)</code>加上启发式<code>g(b)</code>很可能大于一个离<code>goal</code>很远的节点<code>a</code>，因为<code>h(a)</code>必然小于<code>h(b)</code>，估计值永远不高于实际值，很有可能<code>h(a)+g(a)f(a)&lt;f(b)=h(b)+g(b)</code></p> <p><strong>Proof:</strong></p> <ul><li>b is on the fringe</li> <li>n is one of ancestor of a and on the fringe</li> <li>Claim: n will be expanded before b
<ol><li>f(n) is less than f(b)</li> <li>f(a) is less than f(b)</li> <li>n expanded before b</li></ol></li> <li>all ancestors of a will expand before b</li> <li>a will expand before b</li> <li>A* search is optimal</li></ul> <p>当<code>b</code>和<code>n</code>同时存在于<code>fringe</code>，<code>n</code>是<code>a</code>祖先，若<code>g(n)&lt;g(b)、f(a)&lt;=f(n)</code>，又必然<code>h(a)=h(b)</code>，在此时一定会选择<code>n</code>扩展，达到节点<code>a</code>，同理若<code>f(c)&lt;f(n)</code>，一定也会往<code>c</code>扩展</p> <p>不可能发生先到达<code>b</code>再到达<code>a</code>的情况，因为他们总拥有公共祖先，于是具有可容启发式的A*搜索获得了最优性</p> <p><strong>8 Puzzle:</strong></p> <p>启发式：在一个A*搜索中，你可以使用多个可容的启发式，对于同一个节点，选择其最大的启发式值作为<code>h(n)</code></p> <ul><li>位于错误位置的拼图数量（一定小于他所需要移动的次数）</li> <li>总曼哈顿距离，即没有障碍，各个拼图移动到正确位置步数总和</li></ul> <p>后继：空位相邻的滑块滑向空位</p> <h5 id="_1-2-4、graph-search"><a href="#_1-2-4、graph-search" class="header-anchor">#</a> 1.2.4、Graph Search</h5> <blockquote><p>永远不要扩展状态两次</p></blockquote> <p>在A*搜索的基础上，维护一个<code>closed</code>集合记录已经扩展过的节点，在每次扩展时，检查一遍<code>closed</code>集合，如果包含，<code>skip it</code></p> <p>这里数据结构选择<code>set</code>而不是<code>list</code>，会导致很慢捏</p> <p>这样会有一个什么问题：第一次选择了一条没走过但很远的路，导致你一定忽略一些很短但已经被走过的路（如果有）。第一次选择必须十分谨慎</p> <p>为了避免上述问题，我们使用一致性的启发式搜索，又称单调性</p> <ul><li><p>h(n) &lt;= c(n, a, n1) + h(n1)</p> <p>h(n)表示节点n的启发函数值，c(n, a, n1)表示从n经过动作a到达n1的代价，h(n1)为节点n1的启发值</p></li> <li><p>简单来说，就是说启发函数随着节点推移，一定是递增的</p></li> <li><p>这也意味着，你的每一步都将使代价提升，无法后退</p></li></ul> <p>于是具有一致性启发式的图搜索获得了最优性</p> <p>由上可见，高效的启发式搜索是决定性能的关键</p> <h3 id="_2、csps"><a href="#_2、csps" class="header-anchor">#</a> 2、CSPs</h3> <blockquote><p>搜索得前提是世界是确定的</p> <p>Constraint Satisfaction Problems</p> <p>约束满足问题</p></blockquote> <h4 id="_2-1、what-is-csps"><a href="#_2-1、what-is-csps" class="header-anchor">#</a> 2.1、What is CSPs</h4> <p>搜索</p> <ul><li>规划问题</li> <li>识别问题</li></ul> <p>不同于标准搜索问题，标准搜索是黑盒的，只有起始和后继，中间发生了什么是位置的</p> <p>而CSP问题常有以下元素</p> <ul><li>Variables</li> <li>Domains</li> <li>Constraints
<ul><li>Implicit</li> <li>Explicit</li> <li>Unary/Binary/N-ary</li></ul></li></ul> <p>Goals</p> <ul><li>Here：find any solution</li> <li>Also：find all, find best. etc</li></ul> <p>约束限制着域名的选择</p> <p>Map Coloring</p> <ul><li><p>变量：WA, NT, 1, NSW, V, SA, T</p></li> <li><p>域名：red, green, blue</p></li> <li><p>约束</p> <ul><li>implicit: WA != NT</li> <li>explicit: (WA, NT) ∈ {(red, green), (red, blue), (green, red) ...}</li> <li>即相邻的不同变量颜色不能相同</li></ul></li> <li><p>解决方案：</p> <p>{WA=red, NT=green, Q=red, NSW=green, V=red, SA=blue, T=green}</p></li></ul> <p>N-Queens</p> <ul><li>变量：Xij</li> <li>域名：{0, 1}</li> <li>约束：和平的王国</li></ul> <p>Constraint Graphs：约束图</p> <ul><li>arch show constraint</li> <li>variables joined by arch</li> <li>domain selected by state</li></ul> <p>矩形表示约束，弧线表示联系（即存在约束），连接了状态</p> <p>The Waltz Algorithm</p> <blockquote><p>根据平面画出3D图</p></blockquote> <ul><li>CSPs are everywhere</li></ul> <p>试想如何解决CSPs，以地图上色为例</p> <ul><li><p>若用广度优先搜索</p> <p>很明显，所有的解都在最后一层，因为每一层只能给一个州上色，直到底部才能上色完毕，计算量极大</p></li> <li><p>若用深度优先搜索</p> <p>若是盲目深度搜索，他只会不停给每一层某个state上色后继续加深而不管任何约束，能很快找到不满足约束的解，但这很明显不能解决问题</p></li></ul> <h4 id="_2-2、backtracking-serach"><a href="#_2-2、backtracking-serach" class="header-anchor">#</a> 2.2、Backtracking Serach</h4> <p>回溯搜索</p> <blockquote><p>based on dfs</p></blockquote> <p>每次扩展时问一遍自己违反了规则吗，若违反则选择不扩展（说明这个节点之下的整棵树都是错误的），转而考虑其他节点进行扩展</p> <p>通常使用递归回溯代码进行实现</p> <ol><li>以某种顺序选择一个未被遗弃的节点</li> <li>检查
<ul><li>违反约束：回溯，遗弃这颗子树</li> <li>不违反：loop</li> <li>找到答案：return</li></ul></li></ol> <h5 id="_2-2-1、filtering"><a href="#_2-2-1、filtering" class="header-anchor">#</a> 2.2.1、Filtering</h5> <p>前瞻搜索</p> <p>再回溯搜索的基础上，过滤你的候选项，跟踪未分配的域名，进行<code>forward checking</code>，检查当前变量们是否都满足约束</p> <ul><li>domain cloud</li> <li>forward checking</li></ul> <p>但注意他只会检查立即发生的错误，即只推演一步，而不是多步</p> <p>同时约束只会传递到相邻的state</p> <p>这就意味着，只有当问题立即发生，即某个state没有domain选择了，前瞻搜索才会发现出错，这时将进行一个大回溯</p> <p>直到回溯到，弄清楚到底是哪一步就注定了这次失败（有可能是一开始或是第二步），再重新进行选择</p> <ul><li>it's already doomed</li></ul> <p><strong>Constraint Propagation</strong></p> <blockquote><p>约束传递，约束传递越广，前瞻性越好，能更早的发现问题避免回溯</p> <ul><li>Constraint Propagation</li> <li>Forward Checking</li></ul></blockquote> <p>约束一致性</p> <ul><li>arc consistency</li></ul> <p>提前消除冲突的约束，每次做出决定后，对所有后继节点进行检查，消除其有冲突的后继</p> <ul><li>arc police</li></ul> <p>每次删除某个domain时，都要对尚未决定的所有节点重新检查，满足约束的一致性</p> <ul><li>即强行执行约束一致性</li></ul> <p>AC3 Algorithm</p> <ul><li>Two loops</li> <li>当每次做出删除操作，内循环需要重置</li></ul> <p>但他本质上还是一个回溯算法，当强制执行约束一致性无法继续时，仍需要回溯找其他办法</p> <h5 id="_2-2-2、ordering"><a href="#_2-2-2、ordering" class="header-anchor">#</a> 2.2.2、Ordering</h5> <blockquote><p>排序的目的：加速算法</p></blockquote> <p><strong>Minimum Remaining Values</strong></p> <p>在前瞻搜索的基础上，总是选择值域最少的节点进行扩展</p> <p>先找到问题的棘手部分</p> <ul><li>most constrained variable最多受限变量</li> <li>fail-fast机制，有效减少回溯深度</li></ul> <p><strong>Least Constraining Value</strong></p> <p>最小约束价值</p> <h5 id="_2-2-3、consistency"><a href="#_2-2-3、consistency" class="header-anchor">#</a> 2.2.3、Consistency</h5> <blockquote><p>graph structure</p></blockquote> <p>Arc Consistency and Beyond：检查弧和图形的一致性，即对于节点约束的双方，约束都是能够满足的</p> <p>比如V有蓝、绿色选，NSW有蓝色选，二者存在约束，此时他们满足弧的一致性，因为NSW选择了蓝色，V仍有绿色可以选择；但若SA只有蓝色选，NT只有蓝色选，二者存在约束，那么他们不满足弧的一致性，这时则需要回溯</p> <p>与前瞻搜索的区别在于：forward checking只有在问题发生时才能检测到，而arc consistency将领先一步</p> <p>Limitations of Arc Consistency</p> <p>After enforcing arc consistency</p> <ul><li>Can have on solution left</li> <li>Can have multiple solutions left</li> <li>Can have no solutions left and not know it（go backtracking）</li></ul> <p>Arc consistency still runs inside a backtracking search</p> <p>注意每次进行约束判断后，都需要对以往变量重新进行检查，这很昂贵但很有用</p> <p>K-Consistency</p> <ul><li>K=1，代价是无，即保持自身的约束一致性，只要有任意合法域名，便保持1-consistency，代价可以说是无</li> <li>K=2，即为保持弧度一致性</li> <li>K=3，Path Consistency</li></ul> <p>Strong K-Consistency</p> <h5 id="_2-2-4、structure"><a href="#_2-2-4、structure" class="header-anchor">#</a> 2.2.4、Structure</h5> <blockquote><p>图表的结构可以照亮方式</p></blockquote> <p>problem structure</p> <h6 id="_1independent-sub-problem"><a href="#_1independent-sub-problem" class="header-anchor">#</a> ①Independent Sub-Problem</h6> <p>存在独立的子问题，如地图着色中的岛屿，拉出来单独考虑</p> <h6 id="_2tree-structured-csps"><a href="#_2tree-structured-csps" class="header-anchor">#</a> ②Tree-Structured CSPs</h6> <p>no loops：没有循环</p> <p>only on parent：只有一个父母节点，这决定了只需满足上下二者的弧一致性，并一直扩展到叶子，那么一定是满足约束的</p> <p>时间复杂度随变量增多线性增加</p> <ol><li><p>order：选择一个节点作为根节点</p></li> <li><p>Remove backward：对其余所有节点进行弧一致性约束</p> <p>for i = n: 2, apple RemoveInconsistent(Parent(xi). xi)</p></li> <li><p>Assign forward：选择未被选择的节点，开始扩展</p></li></ol> <p>Runtime：O(n d^2)</p> <p>这样做之后，从根节点到叶子节点的每一条路径都是弧一致的，因为我们访问了每个子节点并Make it arc-consistency</p> <h6 id="_3nearly-tree-structured-csps"><a href="#_3nearly-tree-structured-csps" class="header-anchor">#</a> ③Nearly Tree-Structured CSPs</h6> <p><strong>delete</strong></p> <p>Cutest conditioning Algorithm</p> <ul><li>Conditioning：实例化一个变量时，考虑对其邻居的影响，那么当前节点和他的邻居便形成了一种树状结构（残差图），对其邻居的域名进行修剪（prune）</li> <li>Cutest condition：实例化一组变量，直到残差图是一棵树</li> <li>Cutest size c gives runtime O((d^c)(n-c)d^2)，very fast for small c（c应该是实例化的那组变量）</li></ul> <p>那么现在的问题就变成了如何高效地进行剪裁，尽量少地实例化变量而得到一颗树结构的残差图，转化为一个树结构的CSP问题，再使用树结构求解算法</p> <p>delete node until have a tree left</p> <p><strong>grouping</strong></p> <p>以当前节点为中心，对邻居进行分组</p> <p>如当前选择了SA，其余均与其有约束，进行如下分组：<code>{SA, WQA, NT}, {SA, NT, Q}, {SA, Q, NSW}, {SA, NSW, V}</code></p> <p>不能完全单独解决这些子问题，要有一些限制：如相同的变量必须保持相同的值</p> <ul><li>选择必须是连贯的</li></ul> <h4 id="_2-3、local-search"><a href="#_2-3、local-search" class="header-anchor">#</a> 2.3、Local Search</h4> <blockquote><p>局部搜索</p> <p>记住解决CSP问题的基础仍是搜索，这是一个不断优化的过程</p></blockquote> <p>Local Serach的思路是：先完整再合法。即先搜索到某一个叶子节点，该路径并不合法，再对其进行矫正使其合法或失败，这完全不同于之前的搜索，即先保证合法，才能继续搜索</p> <p>即先凑出一个答案，再慢慢修改答案使之合法</p> <h5 id="_2-3-1、iterative-improvement"><a href="#_2-3-1、iterative-improvement" class="header-anchor">#</a> 2.3.1、Iterative Improvement</h5> <blockquote><p>迭代改进</p></blockquote> <p>apply to CSPs</p> <ul><li>Take an assignment with unsatisfied constraints</li> <li>Operators reassign variable values</li> <li>No fringe! Live on the edge</li></ul> <p><code>Operator</code>对应<code>successor function</code>，其功能为：重新分配变量值</p> <p>Algorithm</p> <ul><li>Variable selection: randomly select and conflicted variable</li> <li>Value selection: <strong>min-conficts heuristic</strong> <ul><li>选择违反的价值最少的限制，即最大的减少冲突</li> <li>直到减少的冲突等于违反约束的总数</li></ul></li></ul> <p>找寻变量规则：最小冲突启发式</p> <p>举个例子：有人和你起了冲突要宰你，你有一个机会跑路，那么你总是跑到离他最远的地方。这个地方便是你选择的变量值</p> <ul><li>这有一个致命问题：有可能死锁，即有两个或多个冲突相联系，即解决了1出现了2，解决了2又出现1</li></ul> <p>适用情况：</p> <ul><li>变量很多，约束很少</li> <li>约束很多</li></ul> <p>why?</p> <ul><li>当约束很少，你可以随便选，而且很少触发冲突</li> <li>当约束很多，你的选择极少，可能只有一两种改进方法，这也会算的很快</li></ul> <h5 id="_2-3-2、hill-climbing"><a href="#_2-3-2、hill-climbing" class="header-anchor">#</a> 2.3.2、Hill Climbing</h5> <p>从一个初始点出发，试着让他变得更好，当无法变得更好时（冲突不会继续减少）， stop and declared finished</p> <ul><li>这无法保证搜索完整性和最优性</li></ul> <p>就如爬山时始终朝着比自己高的地方爬，很有可能你会停在一个小山包而不是山顶，是一个局部最大值</p> <p>可怕之处是局部最大值和全局最大值对于身处环境根本没有特征能够区别开来（no sign）</p> <p>所以本地搜索有很多并行运行的线程，从不同初始点开始搜索，希望找到不同的局部最大值，从而找到全局最大值</p> <h5 id="_2-3-3、simulated-annealing"><a href="#_2-3-3、simulated-annealing" class="header-anchor">#</a> 2.3.3、Simulated Annealing</h5> <blockquote><p>退火模拟</p></blockquote> <p>核心思想：jump around</p> <p>温度表：活跃度</p> <ul><li>当0，stop</li> <li>当非常高，瞎几把乱选</li> <li>当在中间，会根据价值和温度进行考虑，决定是否离开本地</li></ul> <p>以此来避开局部最佳</p> <h5 id="_2-3-4、genetic-algorithms"><a href="#_2-3-4、genetic-algorithms" class="header-anchor">#</a> 2.3.4、Genetic Algorithms</h5> <blockquote><p>遗传算法</p></blockquote> <p>简单举例：现在有两个完整的解决办法，但他们都有少数冲突，现在我们将两个办法砍开再重组</p> <h3 id="_3、games"><a href="#_3、games" class="header-anchor">#</a> 3、Games</h3> <blockquote><p>Game Tree and Adversarial Serach</p> <p>博弈树和对抗搜索</p></blockquote> <p>games with ai</p> <ul><li>checkers（solved）</li> <li>chess: deep blue</li> <li>go</li> <li>pacman</li></ul> <p>types of games</p> <ul><li>确定性（围棋）或随机性（吃豆人）</li> <li>玩家数量</li> <li>零和博弈</li> <li>信息是否公开（扑克、围棋）</li></ul> <p>Many possible formalizations</p> <ul><li>states: S（start at s）</li> <li>players: P（1...N）</li> <li>Actions: A</li> <li>Transition: Function: SxA -&gt; S</li> <li>Terminal Test: S -&gt; {t, f}</li> <li>Terminal Utilities: SxP -&gt; R</li></ul> <p>Solution for a player is a policy: S -&gt; A</p> <blockquote><p>the point is: what action should be taken</p></blockquote> <p>Zero-Sum Games</p> <ul><li>博弈双方争夺同一组资源（双人红警），一方资源的增加必然等于另一方资源的减少，是为零和，故双方不存在合作的可能</li> <li>属于非合作博弈</li></ul> <p>General Games</p> <ul><li>有同伴，如MC</li> <li>属于合作博弈</li></ul> <p><strong>Adversarial Game Tree</strong></p> <ul><li>博弈树</li></ul> <p>Single-Agent Trees</p> <ul><li>单策略树</li> <li>Minimax Value：节点的值等于其子节点中的最大值</li> <li>Minimum Value：节点的值等于其子结点中的最小值</li></ul> <h4 id="_3-1、minimax-search"><a href="#_3-1、minimax-search" class="header-anchor">#</a> 3.1、Minimax Search</h4> <blockquote><p>井字棋：确定化的零和游戏</p> <p>like DFS</p></blockquote> <p>这常用于解决公开信息的零和问题：因为玩家回合制操作，在自己的回合要求MAX，在对方的回合要求MIN，Minimax算法正合他意</p> <p><strong>Tic-Tac-Toe Game Tree</strong></p> <p>最小化节点和最大化节点一层一层层交替</p> <ul><li>最小化节点找到下一层节点的最小值为自己赋值</li> <li>最大化节点找到下一层节点的最大值为自己赋值</li> <li>这样的赋值是动态的，实时变化的，直到所有节点被访问</li></ul> <p>最后将会根据根节点值选择相应叶子节点连接成结果路径</p> <table><thead><tr><th>Strategy</th> <th>Time</th> <th>Space</th></tr></thead> <tbody><tr><td>Minimax</td> <td>O(b^m)</td> <td>O(bm)</td></tr> <tr><td>DFS</td> <td>O(b^m)</td> <td>O(bm)</td></tr></tbody></table> <p>当b&gt;35时，搜索整棵树变得不太可能，效率太低辽（Resource limit）</p> <h4 id="_3-2、α-β-pruning"><a href="#_3-2、α-β-pruning" class="header-anchor">#</a> 3.2、α-β Pruning</h4> <blockquote><p>阿尔法贝塔算法：博弈树剪枝的一种方式</p></blockquote> <p>在<code>minimax search</code>的基础上，进行一些价值判断从而跳过一些节点</p> <p>比如上层的最大化节点已经遍历到了一个最大值3，搜索当前最小化节点下层时访问到了一个值为3的节点，那么我们可以直接跳过当前这个最小化节点，因为它一定会返回一个<code>&lt;=3</code>的最小值，而它总会小于等于上层最大化节点的当前值3，不会大于3，不会更新MAX的值</p> <p>General configuration (MIN version)</p> <ul><li>computing the MIN-VALUE node n</li> <li>looping over n's children</li> <li>n's estimate of the childrens' min is dropping（丢给上一层判定）</li> <li>who cares about n's value? MAX-VALUE node m, assume m's value is a</li> <li>when n's estimate worse than a（cur &lt;= a）, skip n and continue computing next MIN-VALUE node</li></ul> <p><strong>Alpha-Beta Pruning</strong></p> <blockquote><p>α-β修剪：减少minimax search的成本</p></blockquote> <ul><li>Alpha：MAX's best option on path to root</li> <li>Beta：MIN's best option on path to root</li></ul> <p>The algorithm like this</p> <div class="language-python line-numbers-mode"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token builtin">max</span><span class="token operator">-</span>value<span class="token punctuation">(</span>state<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
	v <span class="token operator">=</span> MIN_VALUE
    <span class="token keyword">for</span> node n <span class="token keyword">in</span> successor<span class="token punctuation">:</span>
        v <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> value<span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> v<span class="token operator">&gt;=</span> b<span class="token punctuation">:</span> <span class="token keyword">return</span> v
        a <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
    <span class="token keyword">return</span> v

<span class="token keyword">def</span> <span class="token function">min_value</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    v <span class="token operator">=</span> MAX_VALUE
    <span class="token keyword">for</span> node n <span class="token keyword">in</span> successor<span class="token punctuation">:</span>
        v <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> value<span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> v<span class="token operator">&lt;=</span> a<span class="token punctuation">:</span> <span class="token keyword">return</span> v
        b <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
    <span class="token keyword">return</span> v
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li><p>it could be very deep and expensive</p></li> <li><p>good child ordering improves effectiveness of pruning</p> <p>如第一次找计算量最小的子树对Top进行赋值</p></li></ul> <p>这样仍然会消耗很多资源，顶多开个根</p> <p><strong>Depth-Limited Minimax Search</strong></p> <p>于是我们选择使用深度受限的Minimax Search以节省资源，将有限最大深度看作叶子节点，这样会不太准，只是近似值（not solved）</p> <ul><li>如下国际象棋，只往后推8步，而不是63步</li></ul> <p>a danger of replanning agents：</p> <p>当子节点价值一样，父节点将会左右摇摆</p> <p>这取决于你的评估功能，当他不够好时，将会出现很奇怪的行为（如左右摇摆）</p> <p>设计一个细致的评估机制，对各节点适量加权，<code>even worse always exist</code></p> <p>有限深度的影响</p> <ul><li>当深度过少，很难找到合适的解决方案</li> <li>深度增多会导致计算量增大，但更可能赢得游戏</li></ul> <p>当算力有限时，评估功能的准确性和搜索深度决定了是否能找到更有前途的解决方案</p> <ul><li>Evaluation and Depth matters</li></ul> <h4 id="_3-3、expectimax-search"><a href="#_3-3、expectimax-search" class="header-anchor">#</a> 3.3、Expectimax Search</h4> <blockquote><p>we always have uncertain outcomes</p> <p>最大期望搜索</p> <p>机会博弈</p></blockquote> <p>在<code>minimax search</code>和<code>α-β purning</code>时，我们对于下层节点的选择都是随机的，但若优先选择到更优的元素，可以有效对无用数据进行修剪</p> <p>根据概率对各节点进行建模（modeling），但是实际上这种选择是不确定的</p> <p>Expectimax Search</p> <ul><li><p>Max nodes as in minimax search</p> <p>最大节点和最小最大搜索中的最大节点保持一致</p></li> <li><p>Chance nodes are like min nodes but outcome is uncertain</p> <p>机会节点像最小节点，但他的结果是不确定的，是估值、随机的</p></li> <li><p>Calculate their utilities（均值）</p></li> <li><p>Take weighted average（expectation） of children</p></li></ul> <p>计算最佳游戏下的平均得分，选择均分最高的节点拓展，有一种希望得分为均分的想法，以期望优先（均分=选择概率*节点总值）</p> <ul><li>当没有明确概率时，默认平均</li></ul> <p>需要注意的是，这里和最大最小搜索的是同一颗博弈树，只是算法不同</p> <p>举个例子：当你失血过多，是爬出去求救还是立刻自杀</p> <ul><li><p>若是minimax算法，他将选择下一步价值最高的节点，即立即自杀以减少痛苦</p></li> <li><p>若是expectimax算法，他将评估爬出去求救的平均价值（即被救还是痛苦死去）和立刻死去的价值，若求救的均值大于立刻死去，那么他就会选择求救</p> <p>但注意，这里是否被救是不确定的，有可能陷入更悲观的结局</p></li></ul> <p>Expectimax Search</p> <div class="language-python line-numbers-mode"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">value</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> the <span class="token keyword">is</span> a terminal state<span class="token punctuation">:</span> <span class="token keyword">return</span> the state's utility
    <span class="token keyword">if</span> the <span class="token builtin">next</span> agent <span class="token keyword">is</span> MAX<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token operator">-</span>value<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
    <span class="token keyword">if</span> the <span class="token builtin">next</span> agent <span class="token keyword">is</span> EXP<span class="token punctuation">:</span> <span class="token keyword">return</span> exp<span class="token operator">-</span>value<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
    

<span class="token keyword">def</span> <span class="token builtin">max</span><span class="token operator">-</span>value<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
    v <span class="token operator">=</span> MIN_VALUE
    <span class="token keyword">for</span> node <span class="token keyword">in</span> successor<span class="token punctuation">:</span>
        v <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> value<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> v


<span class="token keyword">def</span> exp<span class="token operator">-</span>value<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>
    v <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> node <span class="token keyword">in</span> successor<span class="token punctuation">:</span>
        p <span class="token operator">=</span> probability<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
        v <span class="token operator">+=</span> p<span class="token operator">*</span>value<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
    <span class="token keyword">return</span> v
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><strong>Expectimax Pruning</strong></p> <p>最大期望剪枝</p> <p>由于总有可能存在极端值使均值失衡，最大期望算法不能剪枝</p> <p><strong>Depth-Limited Expectimax</strong></p> <p>深度受限的最大期望搜索</p> <p>可以通过机器学习更准确的预测期望值</p> <p>其核心思想是减少层数的遍历通过均值估计得到一个顶部的近似值</p> <p><strong>Probabilities</strong></p> <p>根据<code>world model</code>，针对不同的情况分配概率</p> <p>注意概率是动态变化的，当你获得的信息越多，概率越准确，估值也越准确</p> <p>Expectations：期望值 —— 分布概率加权</p> <ul><li>如三种概率分别对应三种耗时，那么期望值<code>expectations=0.2x20+0.3x15+0.5x30=24.5</code></li></ul> <p>在Expectimax Search中维护一个概率模型，计算各节点的发生概率，通过简单或复杂的计算或随机确定概率</p> <ul><li>不一定对，只是概率</li></ul> <p><strong>Informed Probabilities</strong></p> <p>当存在一个竞争对手，进行概率计算时，要同时对自己和对方的概率进行建模，这将使概率计算十分昂贵</p> <p>因为各自都有一棵博弈树，当搜索算法不同时，二者树也不尽相同，为了相互匹配将带来更多计算</p> <p>这也意味着在竞争时，你不得不越来越接近你的对手，若对手搜索到了100层，你必须做出相应回应，至少近似的搜索到100层，并希望估值足够好</p> <p><strong>The dangers of optimism and pessimism</strong></p> <p>乐观和悲观的危险</p> <ul><li><p>assuming chance when the world is adversarial（对抗的）</p> <p>太乐观了，太贪了，有时很有效，但不安全</p></li> <li><p>assuming the worst case when it's not likely</p> <p>太怂了，或许最后一个豆就在眼前，鬼在较远处，它也会优先选择远离鬼的方向扩展</p></li></ul> <p>分别对应了<code>Expectimax Search</code>和<code>Minimax Search</code></p> <p>Assumptions vs. Reality</p> <table><thead><tr><th>Packman\Ghost</th> <th>Adversarial</th> <th>Random</th></tr></thead> <tbody><tr><td>Minimax</td> <td>good</td> <td>always waste</td></tr> <tr><td>Expectimax</td> <td>always get eaten</td> <td>good</td></tr></tbody></table> <p><strong>Other Type Game</strong></p> <blockquote><p>Mixed Layer Types</p></blockquote> <p>Backgammon</p> <p>每步二十个扩展</p> <p>深度二搜索 ——&gt; build a world champion</p> <p>Multi-Agent Utilities</p> <h4 id="_3-4、utilities"><a href="#_3-4、utilities" class="header-anchor">#</a> 3.4、Utilities</h4> <blockquote><p>效用</p></blockquote> <p>Maximum Expected Utility</p> <blockquote><p>为什么不用minimax，因为他总会太过敏感，做出不合理的选择</p></blockquote> <p>搜索方式将决定我们玩游戏的方式，即如何选择下一步的方法</p> <p>奖品和彩票（actual utility）</p> <ul><li>Prizes：确定的</li> <li>Lotteries：不确定的（uncertain prizes）</li></ul> <p><strong>Rational</strong></p> <ul><li><p>orderability（明确性）</p> <p>a&gt;b&amp;&amp;b&gt;a ——&gt; a==b</p></li> <li><p>transitivity（传递性）</p> <p>a&gt;b&amp;&amp;b&gt;c ——&gt; a&gt;c</p></li> <li><p>continuity（连续性）</p> <p>a&gt;b&gt;c ——&gt; 你需要在a和c之间抽奖</p></li> <li><p>substitutability（可替代性）</p> <p>a~b ——&gt; 那么所有涉及a的判断可以用b替代</p></li> <li><p>monotonicty（单调性）</p> <p>a&gt;b, P(a)&gt;P(b) ——&gt; select a</p></li></ul> <p>MEU Principle</p> <p>偏好和价值</p> <p><strong>Human Utility</strong></p> <p>极端情况（extremes）</p> <p>效用函数</p> <p>平均操作使行为如一（expectimax）</p> <ul><li>Money</li> <li>Lottery</li> <li>Prizes</li></ul> <p>Human Rationality?</p> <blockquote><p>马尔可夫决策和强化学习</p></blockquote> <h3 id="_4、mdps"><a href="#_4、mdps" class="header-anchor">#</a> 4、MDPs</h3> <blockquote><p>Markov Decision Processes</p> <p>马尔可夫决定过程</p></blockquote> <h4 id="_4-1、what-is-mdps"><a href="#_4-1、what-is-mdps" class="header-anchor">#</a> 4.1、What is MDPs</h4> <p>进程：对搜索的概括</p> <p>计算可能的结果</p> <p>在<code>GridWorld</code>中，你决定向北走（因为这是最佳策略），但可能会执行失败（撞墙）</p> <p>MDP：Reward ——&gt; 结果</p> <ul><li>happy reward</li> <li>bad reward</li></ul> <p>目标很松散 ——&gt;为了最大化奖励的总和</p> <p>An MDP is defined by</p> <ul><li><p>a set of states s</p></li> <li><p>a set of actions a</p></li> <li><p>a transition function T(s, a, s')</p> <ul><li><p>Probability that a from s leads to s', called P(s'| s, a)</p> <p>在s状态执行a行为到达s'的代价</p></li> <li><p>Also called the model or the dynamics</p> <p>不同于搜索，这个后继函数有很多个，如在每个地点都可以向东南西北移动</p></li></ul></li> <li><p>a reward function R(s, a, s')</p> <ul><li><p>sometimes just R(s) or R(s')</p> <p>奖惩制度，有时只取决起点或终点</p></li></ul></li> <li><p>a start state</p></li> <li><p>maybe a terminal state</p></li></ul> <p>MDPs是不确定性搜索问题</p> <ul><li>强化学习的基础</li></ul> <p>expectimax（最大期望算法）算法可以MDP问题</p> <p>action outcomes depend on</p> <ul><li>未来要到达的状态</li> <li>你要执行的行动</li></ul> <p>MDPs适合嘈杂的世界</p> <p><strong>Grid World</strong></p> <p>Policy：策略</p> <ul><li>通过状态告诉你动作的功能</li> <li>如在地图上每个点标好你该往哪个方向走</li></ul> <p>optimal policy：最优策略</p> <ul><li>或许存在很多等效策略</li></ul> <p>competition</p> <ul><li>移动奖励（负0.1）是那么微不足道而不值得冒险去坑附近</li> <li>宁愿什么都不做，也不愿犯错</li></ul> <p>当移动代价变得更大，策略将更倾向与冒险在坑附近</p> <p>当更更大时，甚至有可能直接跳坑而避免移动花销</p> <p><strong>Racing</strong></p> <p>states：</p> <ul><li>cool</li> <li>warm</li> <li>overheated：risk the danger of breaking</li></ul> <p>跟据当前的温度决定是加速还是减速</p> <p><strong>Racing Search Tree</strong></p> <blockquote><p>tool：epectimax search</p></blockquote> <p>actions：</p> <ul><li>slower</li> <li>faster</li></ul> <p>state：</p> <ul><li>warm</li> <li>cool</li> <li>over heated</li></ul> <p>这棵树是无限的</p> <ul><li>Q state：选择了但还没行动的过度状态</li></ul> <p><strong>Utilities of Sequences</strong></p> <p>实用程序的选择顺序</p> <ul><li>more or less</li> <li>now or later</li></ul> <p>隐含的权衡</p> <p><strong>discount</strong></p> <p>对奖励的贬值，对晚来的价值施以惩罚，如每走一步，未得到的价值便腐朽0.8，0.8便是折扣</p> <p>当折扣越大，即<code>λ</code>越小，agent将变得越贪婪，越在意眼前的价值，而不是以后获得更大的利益</p> <p><strong>Preferences</strong></p> <p>假设偏好是固定的</p> <p>two ways to define utilities</p> <ul><li>additive utility</li> <li>discounted utility</li></ul> <p>如何处理无限的问题</p> <ul><li>Finite horizen：similar to depth-limited search，即限定树的深度</li> <li>Discounting：价值总是贬值，将无限接近于0</li> <li>Absorbing state：使用一系列终止状态，即</li></ul> <p>Markov decision processes：</p> <ul><li>状态集</li> <li>初始状态</li> <li>行为集</li> <li>过渡函数：提供的是概率</li> <li>奖惩机制</li></ul> <p>它的输出是每个state上对应的action，他实际上并没有真正在试错，而是去给每个状态分配最佳的行动，这就是MDP</p> <h4 id="_4-2、solving-mdps"><a href="#_4-2、solving-mdps" class="header-anchor">#</a> 4.2、Solving MDPs</h4> <p>Quantities：</p> <ul><li>Policy：map of states of actions</li> <li>Utility：sum of discounted reward</li> <li>Values：expected future utility from a state（max node）</li> <li>Q Values：expected future from a q-state（chance node）</li></ul> <p>Optimal Quantities</p> <ul><li>V(s)*：状态的期望值（或许是平均值）</li> <li>Q*(s, a)：在状态s执行动作a后起的最佳作用</li> <li>P*(s)：当前状态的最佳策略（算法产出）</li></ul> <p>expectimax search可以解决这一问题，估算价值，选出最大价值，赋值</p> <p>考虑一下其他的算法</p> <ul><li><p><code>V*(s) = maxQ*(s, a)</code></p> <p>虽然Q*(s, a)还不知道怎么算</p></li> <li><p><code>Q*(s, a) = avg(sum(R(s, a, s') + λV*(s'))</code></p> <p>这是一个递归的定义，因为你并不知道V*(s')直到搜索到终点</p></li></ul> <p>此之谓贝尔曼方程：Bellman Equations</p> <ul><li>take correct first action</li> <li>kepp being optimal</li></ul> <p>回顾一下Racing Search Tree</p> <p>他是无限的，并且只有三种状态，如果用expectimax search，将会有指数级的重复工作（子树）</p> <h5 id="_4-2-1、value-iteration"><a href="#_4-2-1、value-iteration" class="header-anchor">#</a> 4.2.1、Value Iteration</h5> <p>价值迭代算法</p> <ul><li>from the bottom（deep enough）, recur the top</li> <li><code>V*(s) = maxΣT(s,a,s')[R(s,a,s') + λV*(s')]</code></li></ul> <p>利用贝尔曼方程确实可以搜索到底部并且递归回顶部，在这个递归过程中，各节点的值是不断更新的，且更加准确，直到保持稳定，即递归完毕</p> <ul><li>这个收敛的过程称作<code>bellman update</code></li></ul> <p><strong>Computing Time-Limited Values</strong></p> <p>对于一颗无限树，采用时间限制其递归深度，令V*(s)尽可能准确</p> <p>因为条件有限，我们无法完整进行贝尔曼算法，即只能尽可能的接近V*(s)</p> <ul><li><code>Vk(s) = avg(sum(R(s, a, s') + λVk(s')))</code></li></ul> <p>其中<code>Vk(s)、Vk(s')</code>都取其均值</p> <ul><li>take average</li> <li>像一个单层的expectimax搜索，但不同的是，他会由于递归深度的增加不断调整Vk值</li></ul> <p><strong>Convergence</strong></p> <p>VK compute</p> <p>一个k层树和一个k+1层树</p> <p>由于搜索深度增加，对于未来某节点的折扣也增加，也就是说越往后对总值的影响应是越小，细微调整</p> <p>当discount&gt;=1，没有趋同保证</p> <h5 id="_4-2-2、policy-evaluation"><a href="#_4-2-2、policy-evaluation" class="header-anchor">#</a> 4.2.2、Policy Evaluation</h5> <p>策略评估方法</p> <h6 id="_1fixed-policies"><a href="#_1fixed-policies" class="header-anchor">#</a> ①fixed Policies</h6> <p>固定的策略</p> <ul><li>do the optimal action</li> <li>do what Pi says</li> <li>easier than the optimal</li></ul> <p>假设你的固定策略选出的后继节点是最佳的</p> <ul><li><code>VΠ(s) = ΣT(s,Π(s),s')[R(s,Π(s),s') + λVΠ(s')]</code></li></ul> <p>固定策略例如：一直向右走；一直向前走</p> <p>列举所有策略，评估所有策略，选择得分最高的策略</p> <h6 id="_2policy-evaluation"><a href="#_2policy-evaluation" class="header-anchor">#</a> ②policy evaluation</h6> <p>输入一个策略，执行策略，得到该策略的值向量</p> <p><code>VΠ = ΣT(s,Π(s),s')[R(s,Π(s),s') + λVΠ(s')]</code></p> <h6 id="_3policy-extraction"><a href="#_3policy-extraction" class="header-anchor">#</a> ③Policy Extraction</h6> <p>即使当找到了相邻的最佳值，仍然要做一次expectimax去找到导致这个最佳值的行动</p> <ul><li>从值中找出行动，以更新策略</li></ul> <p>价值驱动决策</p> <p>Computing Actions from Q-Values</p> <h5 id="_4-2-3、policy-iteration"><a href="#_4-2-3、policy-iteration" class="header-anchor">#</a> 4.2.3、Policy Iteration</h5> <p>价值迭代的问题</p> <ul><li>每次迭代将会耗费<code>O(s^2*A)</code>，这很慢</li> <li>每个状态的最大值很少改变，这意味着做了很多低效工作</li></ul> <p>正确策略下的无用选择 ——&gt; 错误的策略试错</p> <p>我们采用策略迭代</p> <ul><li>首先选择一些策略，并执行他们，估算状态价值</li> <li>改善你的策略，再次考虑之前的行动，重复估值</li> <li>直到策略收敛</li></ul> <p>可以证明它是最佳且收敛的，并且在很多情况比价值迭代收敛得更快</p> <p>VΠ是由当前策略得到的当前“最佳值”</p> <p><code>VΠ = ΣT(s,Π(s),s')[R(s,Π(s),s') + λVΠ(s')]</code></p> <p>根据这个当前最佳值，更新上一步的策略，比如我上一步策略原来是往北走，但这个最佳值得往东走，那么我更新上一步的策略为向东走</p> <ul><li>MDPs本质上便是找到每步的最佳策略，值迭代同时考虑策略和价值，在每步做出最佳选择；策略迭代通过值去找到更优的策略</li> <li>二者都是迭代，从叶子回溯到顶部</li></ul> <p>通常根据最后值的变化来确定是否已经收敛</p> <h4 id="_4-3、summary"><a href="#_4-3、summary" class="header-anchor">#</a> 4.3、Summary</h4> <ul><li>compute optimal values：both can</li> <li>compute values for partivular policy：policy evaluation（策略评估）</li> <li>turn your values into policy：use policy extraction（策略抽取）</li></ul> <p>通常Policy Iteration是policy evaluation和policy improvement交替执行直到收敛</p> <p>Value Iteration是寻找Optimal value function和执行一次policy extraction</p> <ul><li>均属于动态规划算法</li></ul> <p><strong>Double-Bandit MDP</strong></p> <p>两台老虎机，一台（blue）拉一次给一块钱；另一台（red）拉一次给0元或2元。共拉一百次</p> <p>更优的策略？</p> <ul><li><code>red one</code>获得2元的概率为0.75</li></ul> <p>平均上</p> <ul><li>blue：100元</li> <li>red：150元</li></ul> <p>当获得2元的概率未知，尝试red one去获得信息</p> <p>core of reinfocement Learning：exploraton</p> <p>只能探索才能获取更多信息</p> <p>pay for the infomation and get return</p> <p>甚至不需要MDP算法，只需要不断探索和基本的数学直觉，试出概率</p> <h3 id="_5、rl"><a href="#_5、rl" class="header-anchor">#</a> 5、RL</h3> <blockquote><p>Reinforcement learning：强化学习</p> <p>It's about how to learn behaviors</p></blockquote> <ul><li>Agent —actions—&gt; Environment</li> <li>Environment —state/reward—&gt; Agent</li></ul> <p>Agent和Environment都是动态变化的</p> <p>Basic idea：</p> <ul><li>agent接收奖惩反馈</li> <li>奖惩函数决定agent的效用</li> <li>为了最大化奖励，必须去学习最优行动</li> <li>所有的学习基于观察样例后的结果</li></ul> <p>learning rather than plan</p> <p>Examples：</p> <ul><li>Robot dog learning to Walk</li> <li>Snake rebot sidewingding（爬墙）</li></ul> <p>因为真实世界的规则并不是确定的，难以建模，这时让程序根据概率学习正确的行为显得更加高效</p> <ul><li><p>Toddler Robot（幼儿机器人）</p> <p>know how to stand after fall down</p></li></ul> <p>机器学习的最开始，他是不知道怎么做的，只是来回摆动，因为他不知道怎么获取奖励，于是开始瞎几把试，当偶然获取奖励后，他将根据奖惩制度完善自己的行动策略，从而行动得更加高效</p> <p>Still assume a Markov decision process</p> <ul><li><p>a set of states</p></li> <li><p>a set of actions</p></li> <li><p>a model T(s,a,s')</p> <p>原为 a successor function T(s,a,s')</p></li> <li><p>a reward function R(s,a,s')</p></li></ul> <p>Still looking for a policy</p> <p>The defference：We don't know T or R</p> <ul><li><p>不知道哪个状态是好的或哪个动作是好的</p> <p>就像那个老虎机不知道掉落概率</p></li> <li><p>必须真正去行动和访问状态去学习，去获取必要信息</p></li></ul> <p>Offline（MDPs） vs. Online（RL）</p> <ul><li>Offline Solution</li> <li>Online Learning</li></ul> <h4 id="_5-1、model-based-learning"><a href="#_5-1、model-based-learning" class="header-anchor">#</a> 5.1、Model-Based Learning</h4> <p>Basic idea：</p> <ul><li>learn an approximate model based on experiences</li> <li>solve for values as if the learned model were correct</li></ul> <p>现根据经验构建模型，再使用问题求解方法去计算当前模型</p> <p>就像一个CSP问题我们不知道联系，得先建立相邻状态联系</p> <p>step1：learn empirical MDP model</p> <ul><li>为每个状态和动作做产出（outcomes）统计</li> <li>常态化评估函数T(s,a,s')</li> <li>每当经历<code>s—a—&gt;s'</code>时计算回报函数R(s,a,s')</li></ul> <p>step2：solve the learned MDP（近似的MDP问题）</p> <ul><li>use value iteration</li> <li>use policy iteration</li> <li>......</li></ul> <p>T和R是未知的，但状态空间和行为空间被分配了，要做的就是收集更多数据，动态改善你的模型，估计T和R函数</p> <p>where the reward function come from</p> <ul><li>depend on the human designer</li></ul> <p>how to calculate T function</p> <ul><li>in a simple example, may just looking at the frequencies（频率）</li></ul> <p>计算概率权值：E（概率x值）</p> <ul><li><p>Known P(A)：E(A) = ΣP(a)*a</p></li> <li><p>Unknown P(A)</p> <ul><li><p>Model Based：E(A) = avg(sum(P(a)*a))</p> <p>以某种策略重新计算概率</p></li> <li><p>Model free：E(A) = (1/N)*sum(a)</p> <p>我们认为各种可能概率是相等的，因为尚未总结出规律</p></li> <li><p>二者区别在于是否按概率加权计算均值</p></li></ul></li></ul> <h4 id="_5-2、model-free-learning"><a href="#_5-2、model-free-learning" class="header-anchor">#</a> 5.2、Model-Free Learning</h4> <h5 id="_5-2-1、value-learning"><a href="#_5-2-1、value-learning" class="header-anchor">#</a> 5.2.1、Value Learning</h5> <blockquote><p>Passive Reinforcement Learning</p> <p>我们不担心如何在世界模型中行动，只是观察行动并视图估计此代理的状态值</p></blockquote> <p>Simplified task：policy evaluation</p> <ul><li>input：a fixed policy（遵循某一策略）</li> <li>don't know T(s,a,s')</li> <li>don't know R(s,a,s')</li> <li>goal：learn the state values</li></ul> <p>Direct &amp; Indirect Evaluation</p> <blockquote><p>直接估值和间接估值</p></blockquote> <p>直接估值平均观察到的样本值，直接问这一步会有多少<code>reward</code>，仅仅依据实验出的结果的各状态值</p> <p>如直接对于个节点的可能取值求均值作为其状态值，如对C节点使用四次策略</p> <ul><li><p>C向D -1，D退出+10</p> <p>C向D -1，D退出+10</p> <p>C向D -1，D退出+10</p> <p>C向A -1，A退出-10</p> <p>那么取均值则为<code>(9+9+9-11)/4=4</code></p></li></ul> <p>不需要对T/R做任何事，求均值就行了，只关注值；这不能达到超精确，但随着数据增加总会愈加接近</p> <p>要做的事很明确：</p> <ul><li>选择一个节点</li> <li>多次使用策略进行扩展</li> <li>对扩展结果进行分析取均</li> <li>对该节点赋值得到<code>V(s)</code></li> <li>更新值和策略</li></ul> <p>这一过程始终没用到T/R函数</p> <ul><li><code>VΠ(s) &lt;-- (1/n)Σsample(i)</code></li></ul> <p>注意这里所有的<code>V(s')</code>都应乘上一个<code>λ(&lt;=1)</code>作为时间惩罚（贬值）</p> <p>Temporal difference learning：</p> <ul><li><code>sample = R(s,Π(s), s') + λV(s')</code></li> <li><code>VΠ(s) &lt;-- (1-a)VΠ(s) + (a)sample</code></li></ul> <p>以上为更新已走过节点的方法</p> <p>每次获得新的sample，都对刚走过的状态<code>s</code>进行更新，以接近精确值</p> <p>在这一过程中，我们从未建立世界模型，即T/R函数，只是根据样例值不断更新状态值，随着时间的推移，将得到精确值</p> <p>优化求均值的方法，让越接近的经历比以前的经历更重要，因为我们后来计算的结果总是更加准确</p> <ul><li><p><code>xn = (xn + (1-a)*xn-1 + (1-a)^2*xn-2+...) / 1+(1-a)+(1-a)^2+...</code></p> <p>xn为第n个样例</p></li> <li><p>这里的a为学习率，应用于迭代方程中</p></li></ul> <p>由于我们从未构建模型，也没有T/R函数，根本无从进行策略迭代</p> <p>为什么不学习<code>Q-Value</code>而是<code>V-Value</code>？</p> <p>没有理由，他不仅同样能实现更新Value，而且可以用于策略更新，属于积极的学习</p> <h5 id="_5-2-2、q-learning"><a href="#_5-2-2、q-learning" class="header-anchor">#</a> 5.2.2、Q-Learning</h5> <blockquote><p>Active Reinforcement Learning</p> <p>担心数据从何处收集，担心采取行动</p></blockquote> <p>also</p> <ul><li>don't know the transitions T</li> <li>don't know the reward R</li> <li>choose the actions now（当前做的）</li> <li>goal：learn the optimal policy/values</li></ul> <p>不同于MDPs，这不是离线测试（毕竟不知道T/R，无法进行推测），而是真切地采取行动</p> <p>iteration</p> <ul><li>从一个确定状态值开始</li> <li>计算该状态值下一层每个状态的Q-Value和Value</li> <li>通过下一层的Q-Value/Value更新该层的Q-Value/Value</li> <li>迭代这一过程，更新所有Q-Value/Value</li></ul> <p>Value Iteration</p> <ul><li><code>Vk+1(s) &lt;-- maxΣT(s,a,s')[R(s,a,s') + λVk(s')]</code></li></ul> <p>Q-Value Iteration</p> <ul><li><code>Qk+1(s,a) &lt;-- ΣT(s,a,s')[R(s,a,s') + λmaxQk(s',a')]</code></li></ul> <p>在这里使用的样例和更新策略</p> <ul><li><p><code>sample = R(s,a,s') + λmaxQk(s',a')</code></p></li> <li><p><code>Q(s,a) &lt;-- (1-a)Q(s,a) + (a)sample</code></p> <p>这个常量a称为学习率</p></li></ul> <p>举例：crawler bot（爬虫机器人）</p> <p>Q-Learning is called off-policy learning</p> <p>Caveats（警告）</p> <ul><li>have to explore enough</li> <li>have to eventually make the learning rate small enough（收敛）</li> <li>...but not decrease it too quickly</li> <li>it doesn't matter how you select actions</li></ul> <table><thead><tr><th>Problem</th> <th>Goal</th> <th>Technique</th></tr></thead> <tbody><tr><td>Known MDP</td> <td>Compute<code>V*,Q*,Π*</code>; Evaluate a fixed policy</td> <td>Value/Policy iteration; Policy evaluation</td></tr> <tr><td>Unknown MDP: Model-Based</td> <td>Compute<code>V*,Q*,Π*</code>; Evaluate a fixed policy</td> <td>VI/PI on approximate MDP; PE on approximate MDP</td></tr> <tr><td>Unknown MDP: Model-Free</td> <td>Compute<code>V*,Q*,Π*</code>; Evaluate a fixed policy</td> <td>Q-learning; Value learning</td></tr></tbody></table> <p>均使用贝尔曼方程进行递归计算</p> <p>Exploration（探索）vs. exploitation（开发）</p> <p>Exploration function</p> <ul><li><p>探索未知节点，收集更多经验：random actions（ε epsilon-greedy）</p> <p>当ε越大，随机度越高，当为0，策略确定</p></li> <li><p>探索方程将根据一个节点的“经验”，如访问过多少次，来给予相应的奖励（访问越多，奖励越低）</p></li> <li><p><code>f(u,n) = u + k/n</code>（基数+奖励/访问次数）</p></li> <li><p>这样能有效腐烂一些无用的节点（越多访问奖励越少）</p></li></ul> <p>Q-Update：加入探索方程</p> <ul><li><p>Regular Q-Update:</p> <p><code>Q(s,a) &lt;-- ΣT(s,a,s')[R(s,a,s') + λmaxQ(s',a')]</code></p></li> <li><p>Modified Q-Update:</p> <p><code>Q(s,a) &lt;-- ΣT(s,a,s')[R(s,a,s') + λmaxf(Q(s',a'),N(s',a'))]</code></p></li></ul> <p>Regret</p> <h5 id="_5-2-3、approximate-q-learning"><a href="#_5-2-3、approximate-q-learning" class="header-anchor">#</a> 5.2.3、Approximate Q-Learning</h5> <p>在实际问题中，状态数、动作会很多很多，很难在Q-Table中去储存每一个Q-Value，这个时候只能做估计</p> <p>w为权重，f为特征值（features）</p> <ul><li><code>V(s) = w1*f1(s)+w2*f2(s)+...+wn*fn(s)</code></li> <li><code>Q(s,a) = w1*f1(s,a)+w2*f2(s,a)+...+wn*fn(s,a)</code></li></ul> <p>你的Q值将是很多经验的加权和，如f1为跳楼的特征值，f2为纵火的特征值，Q将这些情况的经验汇总以某些权重组合</p> <p>当特征值<code>&gt;1</code>说明他鼓励这种差异，反之对差异持消极态度</p> <p>a仍是学习率</p> <ul><li><p><code>Q(s,a) &lt;-- Q(s,a) + a[diff]</code></p> <p>准确的Q值</p></li> <li><p><code>wi &lt;-- wi + a[diff]f(s,a)</code></p> <p>近似的Q值</p></li></ul> <p>当权重降低，其对应的多项式变低，Q得到调整，那么更新权重成为现在的问题</p> <p>这么做的目的无非是想用相对少的数据得到一个相对好的Q函数</p> <p><strong>Optimization</strong></p> <p>最小二乘法处理特征值<code>features</code></p> <ul><li><code>Q(s,a) = w1*f1(s,a)+w2*f2(s,a)+...+wn*fn(s,a)</code></li> <li><code>Q(s,a)=w0 + w1f1(s,a)</code></li></ul> <p>Minimizing Error</p> <ul><li><code>error(w) = (1/2)*(y-Σwk*fk(x))½</code></li></ul> <p>对该函数对w求导得</p> <ul><li><code>-(y-Σwk*fk(x))fm(x)</code></li></ul> <p>Why limiting capacity can help?</p> <p>功能越多并不一定越好，这意味着更高阶的多项式，在函数曲线上更加符合</p> <p>这有可能造成过度拟合（overfitting），即为了满足一些离谱的数据，做出疯狂的拟合</p> <h5 id="_5-2-4、policy-search"><a href="#_5-2-4、policy-search" class="header-anchor">#</a> 5.2.4、Policy Search</h5> <p>尝试不同的策略，看哪一个更好</p> <p>Q-Learning：Q值接近，无法确定这是最好的行动</p> <p>让我们关注行动</p> <p>我们有一些Qvalue，向上向下调整特征值权重，看看有什么变化，好则接收，坏则丢弃，然后继续调整，就像CSP的本地搜索</p> <blockquote><p>直升飞机倒挂着飞会省四倍阻力</p> <p>ai vs. ai and train each other</p></blockquote> <h2 id="二、不确定知识和推理"><a href="#二、不确定知识和推理" class="header-anchor">#</a> 二、不确定知识和推理</h2> <blockquote><p>Probabilistic Reasoning</p></blockquote> <h3 id="_1、probability"><a href="#_1、probability" class="header-anchor">#</a> 1、Probability</h3> <blockquote><p>概率论：不确定性下建模和计算以及人工智能的基础</p></blockquote> <p>example：捉鬼敢死队</p> <ul><li>在一个二维的方阵中，隐藏了一个或多个鬼</li> <li>探针标记坐标：颜色越深鬼越近，但有概率出错，每个点只能标记一次，并且每次标记负分</li> <li>开枪：结束游戏，若打到鬼胜利，若为打到则失败</li></ul> <p>Models：在这里指巨大的联合分布，一个巨大的概率查找表</p> <p><strong>Random Variables</strong></p> <p>随机变量</p> <p>简单分类</p> <ul><li><p>R = is it raining（treu/false）</p></li> <li><p>T = is it hot or cold（hot/cold）</p></li> <li><p>D = how long will it take to drive to work（[0, x)）</p> <p>连续性随机变量</p></li> <li><p>L = where is ghost（{0，0}，{0，1}...）</p></li></ul> <p>有点像CSP问题中<code>state &amp; domain</code>（状态和值域）</p> <p>通常随机变量都是离散型变量</p> <p>在真实模型中随机变量概率为0是毁灭性的，概率总和为1</p> <p>简记</p> <ul><li>P(hot) = P(T=hot)</li></ul> <p><strong>Joint distributions</strong></p> <blockquote><p>联合分布：概率模型的核心</p> <p>给出推荐概率的关键</p></blockquote> <p>联合分布概率，即约束一系列随机变量值的概率，就像真值表</p> <ul><li><code>P(X1=x1,X2=x2,...,Xn=xn)</code></li> <li><code>P(x1,x2,...xn)</code></li></ul> <p>n variables with n domain distrbution size：d^n</p> <p>永远不能写出整个概率空间</p> <p><strong>Probabilistic Models</strong></p> <p>概率模型，一组变量和其概率，像是一个巨大的CSP问题，变量对应状态，概率对应值，各变量间存在约束</p> <p><strong>Event</strong></p> <p>事件是一组随机变量的联合结果，通过联合概率表我们可以计算任一事件的概率</p> <p><strong>Marginal Distributions</strong></p> <p>边缘分布：联合分布的一个子表格</p> <p>如有随机变量x、y及其联合分布表a，我们单独提出x的概率分布表b，那么b就是a的一个边缘分布</p> <p><strong>Conditional Probabilities</strong></p> <p>条件概率，a、b均为某一事件</p> <ul><li>P(a|b) = P(a, b) / P(b)</li></ul> <p>即在b发生的前提下，a发生的概率，可以由联合概率和边缘概率计算得出</p> <p><strong>Conditional Distributions</strong></p> <p>条件分布，这里W、T均为变量，条件分布将是一组概率集，即在T为hot的前提下，变量W的概率分布关系</p> <ul><li>P(W|T=hot)</li></ul> <p>他依据事件发生的事实（具体值），而不是概率分布表，这有区别于边缘分布</p> <ul><li><p><code>P(W=s|T=c) = P(W=s, T=c) / ΣP(W=wi, T=c)</code></p> <p>即某一确定条件概率为其条件和自身都发生的概率除以所有可能发生的概率总和</p></li></ul> <p>所有这些事件的概率集合便是W|T的条件分布表</p> <p>计算条件分布的一般方式：</p> <blockquote><p>the algorithms for base nets</p></blockquote> <ul><li>在概率分布表中选出条件满足的所有行</li> <li>等比例调整他们的概率使其概率和为1</li></ul> <p><strong>Probabilistic Inference</strong></p> <blockquote><p>概率推理</p></blockquote> <p>从已知的概率基于证据推理未知的概率，得到期望的概率</p> <p><strong>Inference by Enumeration</strong></p> <p>枚举推理</p> <ul><li><p>Evdence variables：E1...Ek=e1...ek</p> <p>已知事实</p></li> <li><p>Query* variable：Q</p> <p>查询变量，即要推理的问题，想要计算的结果</p></li> <li><p>Hidden variables：H1...Hr</p> <p>尚未证实的事实，也属于未知变量</p></li></ul> <p>推理过程</p> <p>step 1：select the entries consistent with the evidence</p> <ul><li>查询出一个与Q有关的联合概率分布表</li></ul> <p>step 2：sum out H to get joint（联合） of Query and evidence</p> <ul><li><p>Query</p> <p>根据Q合并相同特征的行。如Q为推断天气情况，那么温度和季节将是隐藏变量，你将在使隐藏变量塌陷，将所有<code>W=sun</code>和<code>W=rain</code>提出并合并成两行（subtable）</p></li> <li><p>Evidence</p> <p>根据已知证据（条件），筛选有用的概率分布，如已知是冬天，那么将去掉所有<code>S!=冬天</code>的行</p> <p>条件越多，筛选结果越少</p></li></ul> <p>step 3：normalize</p> <ul><li>即将概率总和等比率扩大至1，转化为一个规范的概率表</li></ul> <p>隐藏变量均具有转化为证据的潜力</p> <p>Obvious problems</p> <ul><li><p>worst case time complexity O(d^n)</p> <p>查询整张联合概率分布表</p></li> <li><p>space complexity O(d^n) to store the joint distribution</p> <p>需要O(d^n)的空间储存联合概率表</p></li></ul> <p>How to produce joint distribution?</p> <p><strong>The Product Rule</strong></p> <ul><li><code>P(y) * P(x|y) = P(x,y)</code></li></ul> <p>根据局部条件分布推断联合概率分布</p> <p><strong>The Chain Rule</strong></p> <p>连锁规则，对于<code>P(y) * P(x|y) = P(x,y)</code>的推广</p> <ul><li><code>P(x1,x2,x3) = P(x1) * P(x2|x1) * P(x3|x1x2)</code></li> <li><code>P(x1,x2,...,xn) = ∏P(xi|x1...xi-1)</code></li></ul> <p>先获得<code>P(x1)</code>，通过条件<code>P(x1),P(x2|x1)</code>计算<code>P(x2,x1)</code>，通过<code>P(x2,x1),P(x3|x1,x2)</code>获得<code>P(x3,x1,x2)</code>，以此类推，最终可以获得<code>P(x1,x2,...,xn)</code></p> <p><strong>Bayes Rule</strong></p> <p>Product rule：<code>P(x,y) = P(x|y)P(y) = P(y|x)P(x)</code></p> <p>移项可得：<code>P(x|y) = (P(y|x)/P(y)) * P(x)</code></p> <p>why it's helpful?</p> <p>通过转换条件（在反向条件中构建条件），通过更简单的条件进行建模</p> <p><strong>Inference with Bayes' Rule</strong></p> <p>例子：诊断病例<code>P(致病因素|症状)</code></p> <ul><li><p><code>P(cause|effect) = (P(effect|cause)P(cause)) / P(effect)</code></p></li> <li><p>cause：脑膜炎</p></li> <li><p>effect：颈部僵硬</p></li></ul> <p>已知：颈部僵硬在普通人群中概率，颈部僵硬在脑膜炎患者之间的概率</p> <p>当你不知道得没得脑膜炎时，因为没有症状，但突然间脖子僵硬了，你就需要重新考虑你得脑膜炎的概率</p> <p>从果溯因的思想，从更多的结果不断更新因的概率使之准确</p> <p><strong>Probabilistic Models</strong></p> <blockquote><p>概率建模</p></blockquote> <ul><li>describe how (a part of) the world works</li></ul> <p>建模总是一个简化过程</p> <ul><li>从哪获取变量</li> <li>怎么计算概率</li> <li>如何学习</li></ul> <blockquote><p>All models are wrong, but some are useful</p> <p>——Geoge E. P. Box</p></blockquote> <p>我们的任务便是提出有用的模型</p> <p><strong>Utility</strong></p> <blockquote><p>模型的效用</p></blockquote> <ul><li>推理未知变量</li> <li>预测，因果推理</li> <li>通过已知变量做出理性决定</li></ul> <p><strong>independence</strong></p> <blockquote><p>随机变量的独立性</p></blockquote> <ul><li><code>P(x,y) = P(x)P(y)</code></li> <li><code>P(x|y) = P(y)</code></li></ul> <p>条件概率等于自身概率，就是说y发不发生对于x是否发生不产生影响，x、y相互独立，是两个一维表，而不是一个联合概率二维表，如抛硬币字面和花面互不影响，二者独立</p> <p>很多时候很多事都不是完全独立的</p> <p>如何检验是否独立？</p> <p>边缘概率相乘是否等于联合概率，若相等则独立，若不等则相关</p> <p>像抛硬币这样的独立情况是很罕见的，我们可以只通过一组概率推断一个很大的概率分布表（因为每次都不变）</p> <ul><li>变量往往有互动，因为你在建模的时候，为什么会选择两个完全无关的变量参与呢</li> <li>更多时候是有条件独立（Conditional Independence）</li></ul> <p><strong>Conditional Independence</strong></p> <blockquote><p>条件独立</p></blockquote> <p>呃就是说，a和b的相关需要条件c，比如a是发现蛀牙，b是牙疼，c是你有牙</p> <p>那么，<code>P(a|b) != P(a)</code>当且仅当<code>c</code>成立，否则<code>P(a|b) = P(a)</code>，即a、b相互独立</p> <ul><li><p>牙疼和发现蛀牙是独立的当没有牙</p> <p>toothcache ⊥ catch | no tooth</p></li></ul> <p>条件独立：</p> <ul><li><p><code>P(x,y|z) = P(x|z)P(y|z)</code></p></li> <li><p><code>P(x|z,y) = P(x|z)</code></p> <p>在z发生时，x、y独立，y是否发生不影响x发生概率</p></li></ul> <p>think about these domain</p> <ul><li>traffic</li> <li>umbrella</li> <li>raining</li></ul> <p>在下雨时交通和雨伞相关联，不下雨时相互独立</p> <ul><li>fire</li> <li>smoke</li> <li>alarm</li></ul> <p>当没有烟雾，火灾和警报将互不关联（烟雾报警器）</p> <p>对于一个Chain Rule</p> <ul><li><code>P(x,y,z) = P(z)P(y|z)P(x|z,y)</code></li></ul> <p>若x、y关于z条件独立，那么这个规则可以简化为</p> <ul><li><p><code>P(x,y,z) = P(z)P(y|z)P(x|z)</code></p> <p>即将<code>P(x|z,y)</code>简化为<code>P(x|y)</code></p></li></ul> <p>这样我们能通过更少的变量主键确定一张联合概率表</p> <h3 id="_2、bayes-nets"><a href="#_2、bayes-nets" class="header-anchor">#</a> 2、Bayes' Nets</h3> <blockquote><p>贝叶斯网络</p> <p>一种用于构建概率模型的技术，管理和推理超过规模的不确定性</p></blockquote> <h4 id="_2-1、representation"><a href="#_2-1、representation" class="header-anchor">#</a> 2.1、Representation</h4> <blockquote><p>表示法</p></blockquote> <p><strong>Big Picture</strong></p> <p>概率模型等于一整个概率分布表？</p> <ul><li>数学上这很好</li> <li>大小是指数型的，真的很大</li> <li>很难去进行学习、评估</li></ul> <p><strong>Example</strong></p> <p>Insurance：汽车保险</p> <ul><li>a lot of variables：age、car、skill...</li> <li>accident：want to prediction</li></ul> <p>所有这些变量根据联系构建了一张大的关系网</p> <p><strong>Graphical Model Notation</strong></p> <blockquote><p>图形模式表示法</p></blockquote> <p>just like CSPs</p> <ul><li>nodes：变量，variables</li> <li>domains：值域，变量的值</li> <li>arcs：用弧表示条件独立性</li></ul> <p><strong>Example</strong></p> <p>1、Coin Flips</p> <p>硬币翻转问题，绝对的独立性，对应一堆没有弧线的节点</p> <p>2、Traffic</p> <p>交通问题，变量为天气和交通</p> <ul><li><p>model 1：independence</p></li> <li><p>model 2：rain causes traffic</p> <p>箭头从下雨指向交通</p></li></ul> <p>model 2 is better</p> <p>3、Traffic Ⅱ</p> <p>交通问题Ⅱ，变量有交通T、下雨R、低气压L、屋顶滴雨D、一个球赛B、蛀牙C</p> <ul><li>低气压影响下雨</li> <li>下雨影响交通、屋顶滴雨、球赛</li> <li>球赛影响交通</li> <li>蛀牙独立于其他变量</li></ul> <p>4、Alarm Network</p> <p>报警装置，变量有入室盗窃B、警报响起A、玛丽打电话来M、约翰打电话来J、地震E</p> <ul><li>入室盗窃导致警报响起</li> <li>地震导致警报响起</li> <li>警报响起导致玛丽和约翰打电话来</li></ul> <p><strong>Bayes' Net Semantics</strong></p> <blockquote><p>贝叶斯网络定义：一种拓扑结构</p></blockquote> <p>贝叶斯网络是一组节点，每个变量x对应一个节点</p> <p>在这些节点中有一个有向无环图，对应变量间的联系（因果关系），注意图中没有定向循环</p> <p>一个节点可能有多个因，果继承了因的某些功能并且呈指数增长，我理解为条件概率在传递过程中不断变化</p> <p>每个节点的概率都是相对其父母节点的条件概率，整合所有的条件概率可以获得一张联合概率表，通过链规则或其他</p> <p>CPT：条件概率表（conditional probability table）</p> <p>不一定是因果关系，异或等都有可能</p> <p><strong>Probabilities in BNs</strong></p> <p>基于Chain Rule，链规则的扩展</p> <p><code>P(x1,x2,...,xn) = ∏ P(xi|parents(Xi))</code></p> <p>贝叶斯网络提供保证，通过乘积将得到节点概率</p> <p>可以通过一个拓扑图将上述例子画出，并提供相应的计算方式</p> <p>在贝叶斯网中，因果关系被弱化，由数字和字母表示，程序并不知道这些数字和字母背后的因果，只是得到一张巨大的联合概率分布表</p> <h4 id="_2-2、conditional-independence"><a href="#_2-2、conditional-independence" class="header-anchor">#</a> 2.2、Conditional Independence</h4> <blockquote><p>条件独立</p></blockquote> <p><strong>Size of a Bayes' Net</strong></p> <p>N Boolean variables：<code>2^N</code></p> <p>N-node net and nodes have up to k parents：<code>O(N*2^(k+1))</code></p> <p>若单纯的计算联合概率分布，指数增长将令算法陷入困境</p> <p>贝叶斯网络将有效缓解</p> <ul><li>条件概率表远小于完整联合概率表</li></ul> <p><strong>Assumptions</strong></p> <p>我们总通过条件概率的乘积来表示当前变量概率，不同于链规则调整所有的条件，贝叶斯网络只根据父级概率进行调整，只关心父母节点</p> <p>举个例子：X ——&gt; Y ——&gt; Z ——&gt; W</p> <p>Chain Rule：<code>P(x,y,z,w) = P(x)P(y|x)P(z|x,y)P(w|x,y,z)</code></p> <p>NBs：<code>P(x,y,z,w) = P(x)P(y|x)P(z|y)P(w|z)</code></p> <ul><li>基于条件独立的简化</li> <li>条件独立是可以传递的，如这里w和z条件独立与y，我们也可以说w和x条件独立与y或z</li></ul> <p>另一个例子：X ——&gt; Y ——&gt; Z</p> <p>X和Z保证独立吗？</p> <p>他们不保证独立，X可以影响Z当Y发生，如低气压引发下雨，下雨引发堵车，那么我们有结论则低气压可以引发堵车当低气压引发了下雨</p> <p>当X发生时，Y发生概率为0时，X和Z保持独立，就像X为抛硬币字面，Y为花面，那么我们可以说这个贝叶斯网络有点智障</p> <h5 id="_2-2-1、d-separation"><a href="#_2-2-1、d-separation" class="header-anchor">#</a> 2.2.1、D-Separation</h5> <blockquote><p>D分离</p></blockquote> <p><strong>Causal Chains</strong></p> <p>因果链</p> <p>例子：X（low pressure） ——&gt; Y （rain）——&gt; Z（traffic）</p> <ul><li><p>无法保证X/Z独立</p></li> <li><p>能够保证X/Z关于条件Y独立，得到简化</p> <p><code>P(z|x,y) = P(x,y,z)/P(x,y) = P(x)P(y|x)P(z|y)/P(x)P(y|x) = P(z|y)</code></p> <p>从公式中可以看到当前节点概率只与其父母节点有关</p></li></ul> <p><strong>Common Cause</strong></p> <p>公共条件，即一个诱因对应多个结果，两或多个个效果由同一个条件导致</p> <p>条件概率选择</p> <p>例子：X ——&gt; Y ——&gt; Z/W</p> <ul><li><p>通常X/Z不会独立</p></li> <li><p>X和Z/W关于Y条件独立，当Y发生，X肯定发生，不对Z/W造成任何影响</p> <p><code>P(z|x,y) = P(z|y)</code></p></li></ul> <p><strong>Common Effect</strong></p> <p>相同效果，即多个诱因可能导致相同的结果。一个结果可以由多个因素导致</p> <p>例子：X/Y ——&gt; Z</p> <ul><li><p>在这个例子中X/Y是否独立</p> <p>yes</p></li> <li><p>X/Y是否关于Z条件独立</p> <p>no，当Z发生，X/Y都有可能发生，当拥有证据X发生了，那么Y的发生概率将会降低</p></li></ul> <p><strong>The General Case</strong></p> <p>一般情况，以三元组为例</p> <p>Reachability：可到达性</p> <p>通常在贝叶斯网络中将隐藏一些证据节点，观察贝叶斯图中其他节点的结果进行推断</p> <p>Active/Inactive Paths</p> <ul><li>链结构：中间无证据，活跃</li> <li><code>V</code>结构：中间有证据，活跃</li> <li><code>^</code>结构：中间无证据，活跃</li></ul> <blockquote><p>以上为D-Separation的轮廓</p></blockquote> <p>Query：<code>Xi⊥Xj | {Xk1,...,Xkn}</code></p> <p>Check：检查Xi到Xj间的所有路径，若有任一一条路径是活跃的，那么Xi和Xj不相互独立；否则二者独立</p> <p>Example：</p> <p>R/B ——&gt; T ——&gt; T'</p> <ul><li>R⊥B：yes（独立）</li> <li>R⊥B|T：no（关联）</li> <li>R⊥B|T'：no（关联）</li></ul> <p>L ——&gt; R ——&gt; D/T，B ——&gt; T ——&gt; T'</p> <ul><li>L⊥T'|T：yes（R-T-T'为非活跃）</li> <li>L⊥B：yes</li> <li>L⊥B|T：no（条件相关）</li> <li>L⊥B|T'：no</li> <li>L⊥B|T,R：yes</li></ul> <p>R ——&gt; T/D，T/D ——&gt; S</p> <ul><li>T⊥D：no</li></ul> <h4 id="_2-3、inference"><a href="#_2-3、inference" class="header-anchor">#</a> 2.3、Inference</h4> <h4 id="_2-4、sampling"><a href="#_2-4、sampling" class="header-anchor">#</a> 2.4、Sampling</h4> <h2 id="三、机器学习"><a href="#三、机器学习" class="header-anchor">#</a> 三、机器学习</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/Blog/ai/course/pre/Optimization.html">
        最优化导论
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Blog/assets/js/app.5b462d01.js" defer></script><script src="/Blog/assets/js/2.6b285d51.js" defer></script><script src="/Blog/assets/js/9.6887a164.js" defer></script>
  </body>
</html>
